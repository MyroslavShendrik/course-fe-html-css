console.log(
    '%c 1.Присвоєння за значенням і за посиланням  ',
    'color: white; background-color: #D33F49',
);

//! Присвоєння за значенням
console.warn("Присвоєння за значенням:");
//? За умови передачі за значенням,
//? змінним виділяється нова комірка пам'яті
//? і в неї копіюються дані.
let a = 5;
//? Присвоєння за значенням: в пам'яті буде створена ще
//? одна комірка, в яку буде скопійоване значення 5
let b = a;
console.log("a:", a); //! 5
console.log("b:", b); //! 5
console.log(". . . .");

//? Змінимо значення a на 10:
a = 10;
console.log("a:", a); //! 10
//? Значення b не змінилося, оскільки це окрема копія:
console.log("b:", b); //! 5
console.log("--------------------------------------");


//! Присвоєння за посиланням 
console.warn("Присвоєння за посиланням:");
//? Складні типи - об'єкти, масиви, функції присвоюються за посиланням,
//? тобто змінна просто отримує посилання на вже існуючий об'єкт.
const arrA = ["Mango"];
//? Оскільки arrA - це масив, в arrB записується посилання на вже існуючий
//? в пам'яті масив arrA. Тепер arrA і arrB вказують на один і той же масив:
const arrB = arrA;
console.log("arrA:", arrA); //! ['Mango']
console.log("arrB:", arrB); //! ['Mango']
console.log(". . . . . . . . . . . . . . . . . . . .");

//? Змінимо масив, додавши ще один елемент,
//? використовуючи вказівник з arrA:
arrA[1] = "Poly"; //todo: var.1
// arrA.push("Poly"); //todo: var.2
console.log("arrA:", arrA); //! ['Mango', 'Poly']

//? arrB також змінилось, тому що arrB,
//? як і arrA, просто містять посилання на 
//? одне і те ж саме місце в пам'яті:
console.log("arrB:", arrB); //! ['Mango', 'Poly']
console.log(". . . . . . . . . . . . . . . . . . . .");

//? Результат повторюється, 
//? якщо додати ще один елемент до arrB:
arrB[arrB.length] = "Ajax"; //todo: var.1
// arrB.push("Ajax"); //todo: var.2
console.log("arrA:", arrA); //! ['Mango', 'Poly', 'Ajax']
console.log("arrB:", arrB); //! ['Mango', 'Poly', 'Ajax']
console.log("--------------------------------------");
