console.log(
    '%c 6.Метод filter(). ',
    'color: white; background-color: #D33F49',
);

//! 6.Метод filter()
console.warn("Синтаксис методу filter():");
//? ✴️ Метод filter(callback) використовується
//? для єдиної операції - фільтрації масиву,
//? тобто, коли необхідно вибрати
//? більше одного елемента з колекції за певним критерієм.
//? 🔸 Поелементо перебирає оригінальний масив.
//? 🔸 Не змінює оригінальний масив.
//? 🔸 Повертає новий масив.
//? 🔸 Додає у масив, що повертається, елементи,
//?    які задовольняють умови колбек-функції.
//? 🔸 Якщо колбек повернув true,
//?    елемент додається у масив, що повертається.
//? 🔸 Якщо колбек повернув false,
//?    елемент не додається у масив, що повертається.
//? 🔸 Якщо жоден елемент не задовольнив умову,
//?     повертає порожній масив.
//? ✳️ Аргументи колбек-функції - це:
//? 🔹 значення поточного елемента element,
//? 🔹 його індекс index
//? 🔹 і власне вихідний масив array.
console.log(
    `%c
    масив.filter((element, index, array) => {
        // тіло колбек-функції
    });
    `,
    'color: blue; font-size: 18px',
);

console.warn("Приклад використання метода filter():");
//? ✳️ Метод filter викликає колбек-функцію
//? для кожного елемента вихідного масиву і,
//? якщо результат її виконання - true,
//? додає поточний елемент у новий масив.
const values = [51, -3, 27, 21, -68, 42, -37];
console.log("values_before:", values); //! [51, -3, 27, 21, -68, 42, -37]

const positiveValues = values.filter(value => value >= 0);
console.log("positiveValues:", positiveValues); //! [51, 27, 21, 42]

const negativeValues = values.filter(value => value < 0);
console.log("negativeValues:", negativeValues); //! [-3, -68, -37]

const bigValues = values.filter(value => value > 1000);
console.log("bigValues:", bigValues); //! []

//todo: Оригінальний масив не змінився:
console.log("values_after:", values); //! [51, -3, 27, 21, -68, 42, -37]
console.log(". . . . . . . . . . . . . . . . . . . . . . . . . . .");


//! Фільтрація унікальних елементів​
console.warn("Фільтрація унікальних елементів:");
//? ✴️ Використовуючи метод filter(),
//? можна виконати фільтрацію масиву таким чином,
//? що у ньому залишаться тільки унікальні елементи.
//? Цей прийом працює тільки
//? з масивом примітивних значень - не з об'єктами.
//? ✳️ Повернемося до групи студентів
//? і масиву усіх відвідуваних предметів,
//? які ми отримали методом flatMap().
const students = [
    { name: "Манго", courses: ["математика", "фізика"] },
    { name: "Полі", courses: ["інформатика", "математика"] },
    { name: "Ківі", courses: ["фізика", "біологія"] },
];
console.log("students:", students);
console.log("`  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `");

const allCoursesByMap = students.map(student => student.courses); // ❌
console.log("allCoursesByMap:", allCoursesByMap); //! [['математика', 'фізика'], ['інформатика', 'математика'], ['фізика', 'біологія']];

const allCourses = students.flatMap(student => student.courses); // ✅
console.log("allCourses:", allCourses); //! ['математика', 'фізика', 'інформатика', 'математика', 'фізика', 'біологія'];

//? ✳️ У змінній allCourses зберігається
//? масив усіх відвідуваних предметів,
//? які можуть повторюватися.
//? Завдання полягає у тому,
//? щоб створити новий масив,
//? в якому будуть тільки унікальні предмети,
//? тобто без повторень.
//? ❓❓❓ ЯК ЦЕ ПРАЦЮЄ:
//? 🟡 Для елемента 'математика' під індексом 0:
//?    ⏩ indexOf() поверне 0, тому що шукає перший збіг
//?    ⏩ Значення параметра index буде 0
//?    🟩 Вони рівні, а отже, це унікальний елемент
//? 🟡 Для елемента 'математика' під індексом 3:
//?    ⏩ indexOf() поверне 0, тому що шукає перший збіг
//?    ⏩ Значення параметра index буде 3
//?    🟥 Вони не рівні, а отже, це повторюваний - не унікальний елемент.
const uniqueCourses = allCourses.filter(
    (course, index, array) => array.indexOf(course) === index
);
console.log("Масив унікальних курсів:", uniqueCourses); //! ['математика', 'фізика', 'інформатика', 'біологія']
console.log("----------------------------------------------------------------------------------------------");


//! Масив об'єктів
console.warn("Масив об'єктів:");
//? ✴️ Під час роботи з масивом об'єктів виконується
//? фільтрація за значенням певної властивості.
//? У підсумку, утворюється новий масив відфільтрованих об'єктів.
//? ✳️ Наприклад, у нас є масив студентів з балами за тест.
//? Необхідно відфільтрувати:
//?  - кращих(бал вище 80),
//?  - середніх студентів(бал від 50 до 80) і,
//?  - гірших(бал нижче 50).
const LOW_SCORE = 50;
const HIGH_SCORE = 80;
const disciples = [
    { name: "Манго", score: 83 },
    { name: "Полі", score: 59 },
    { name: "Аякс", score: 37 },
    { name: "Ківі", score: 94 },
    { name: "Х'юстон", score: 64 },
];
console.log("disciples:", disciples);
console.log("`  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `  `");

const best = disciples.filter(student => student.score >= HIGH_SCORE);
console.log("Кращі учні:", best); //! Масив об'єктів з іменами Манго і Ківі

//todo: В колбек-функції зручно деструктуризувати властивості об'єкта:
const average = disciples.filter(
    ({ score }) => score >= LOW_SCORE && score < HIGH_SCORE
);
console.log("Середні учні:", average); //! Масив об'єктів з іменами Полі і Х'юстон

const worst = disciples.filter(student => student.score < LOW_SCORE);
console.log("Гірші учні:", worst); //! Масив з одним об'єктом Аякс
console.log("----------------------------------------------------------------------------------------------");
