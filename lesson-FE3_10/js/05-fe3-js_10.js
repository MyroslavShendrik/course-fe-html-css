console.log(
    '%c 5.Стрілкові(cтрілочні) функції. \n   Неявне повернення.            \n   Псевдомасив arguments.        \n   Стрілкові функції як колбеки. ',
    'color: white; background-color: #D33F49',
);

//! Стрілкові(cтрілочні) функції
console.warn("Стрілкові(cтрілочні) функції:");
//? Стрілочні функції мають скорочений, лаконічніший синтаксис,
//? що зменшує обсяг коду, особливо коли функція маленька
//? або якщо вона використовується як колбек.
//? Усі стрілки створюються як функціональний вираз (function expression),
//? і якщо функція - не анонімна, її необхідно присвоювати змінній.
//todo: Звичайне оголошення функції:
function classicAdd(a, b, c) {
    return a + b + c;
};
console.log("classicAdd(1, 2, 3);", classicAdd(1, 2, 3)); //! 6
console.log(". . .  . . . .  . . . . . . . . . . . . . . . . . . . .");

//? Якщо у стрілковій функції є декілька параметрів ,
//? то вони перераховуються через кому в круглих дужках,
//? так само, як в приладі з function classicAdd(a, b, c),
//? між знаками дорівнює = та стрілкою =>.
//todo: Оголошення функції стрілочною функцією (декілька параметрів):
const arrowAdd = (a, b, c) => {
    return a + b + c;
};
console.log("arrowAdd(10, 20, 30);", arrowAdd(10, 20, 30)); //! 60
console.log(". . .  . . . .  . . . . . . . . . . . . . . . . . . . .");

//? Якщо параметр один, його можна оголошувати без круглих дужок.
//todo: Оголошення функції стрілочною функцією (один параметр):
const add = a => {
    return a + 5;
};
console.log("add(10);", add(10)); //! 15
console.log(". . .  . . . .  . . . . . . . . . . . . . . . . . . . .");

//? Якщо параметри відсутні, то обов'язково повинні бути порожні круглі дужки..
//todo: Оголошення функції стрілочною функцією (параметри відсутні):
const greet = () => {
    return "Привіт!"
};

console.log("greet();", greet()); //! 15
console.log("-------------------------------------------------------");


//! Явне та неявне повернення
//? У стрілочної функції після символу =>
//? знаходиться її тіло.
//? Існує два варіанти: з фігурними дужками і без них.


//! Явне повернення
console.warn("Явне повернення:");
//? Якщо є фігурні дужки, і функція повинна повертати якесь значення, 
//? необхідно явно поставити return. 
//? Це називається явне повернення (explicit return). 
//? Такий синтаксис використовується у разі, 
//? якщо в тілі функції потрібно виконати ще якісь інструкції, 
//? крім повернення значення.
const arrowAdd2 = (a, b, c) => {
    console.log(a, b, c);
    return a + b + c;
};
console.log("arrowAdd2(100, 200, 300);", arrowAdd2(100, 200, 300)); //! 600
console.log("-------------------------------------------------------");


//! Неявне повернення
console.warn("Неявне повернення:");
//? Якщо фігурні дужки відсутні,
//? то повертається результат виразу,
//? який стоїть після =>.
//? Це називається неявне повернення (implicit return).
//?  У прикладі повернеться результат виразу додавання параметрів a, b і c.
const arrowAdd3 = (a, b, c) => a + b + c;
console.log("arrowAdd2(1000, 2000, 3000);", arrowAdd2(1000, 2000, 3000)); //! 6000
console.log("-------------------------------------------------------");


//! Псевдомасив arguments
console.warn("Псевдомасив arguments:");
//? У стрілочних функцій НЕМАЄ локальної змінної arguments, 
//? що містить усі аргументи. 
//? Якщо необхідно зібрати всі аргументи в масив, 
//? використовується операція rest.
const add4 = (...args) => {
    console.log("args:", args);
};

add4(1, 2, 3); //! args: [1, 2, 3]
console.log("-------------------------------------------------------");


//! Стрілкові функції як колбеки
console.warn("Приклад-1: Анонімні стрілкові функції як колбеки:");
//? Анонімні стрілочні функції відмінно підходять
//? як колбеки для перебираючих методів масиву
//? завдяки коротшому синтаксису оголошення,
//? особливо, якщо не потрібне тіло функції.
const numbers1 = [5, 10, 15, 20, 25];

//todo: Оголошення функції
//todo: Виклик функції з оголошенням функції як колбек
numbers1.forEach(function (number, index) {
    console.log(`Індекс: ${index}, значення: ${number}`);
});
console.log(". . . . . . . . . . . . . . . . . . . . . . . . . . . .");

//todo: Анонімна стрілочна функція
//todo: Виклик функції з анонімною стрілочною функцією як колбек
numbers1.forEach((number, index) => {
    console.log(`Індекс: ${index}, значення: ${number}`);
});
console.log("-------------------------------------------------------");


console.warn("Приклад-2: Стрілкові функції як колбеки:");
//? Стрілочну колбек-функцію також можна оголошувати окремо 
//? і передавати на неї посилання. 
//? Це варто робити, якщо одна функція використовується 
//? у декількох місцях програми або якщо вона громіздка.
const numbers2 = [5, 10, 15, 20, 25];

const logMessage = (number, index) => {
    console.log(`Індекс ${index}, значення ${number}`);
};

//todo: Виклик функції зі стрілочною функцією як колбек
numbers2.forEach(logMessage);
console.log("-------------------------------------------------------");
